import React, { useState, useEffect, useRef } from 'react';

const BiologyGame = () => {
  const [currentLanguage, setCurrentLanguage] = useState('en');
  const [currentLevel, setCurrentLevel] = useState('');
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [score, setScore] = useState(0);
  const [questions, setQuestions] = useState([]);
  const [showGameArea, setShowGameArea] = useState(false);
  const [showCelebration, setShowCelebration] = useState(false);
  const [feedback, setFeedback] = useState({ show: false, type: '', message: '' });
  const [draggedItems, setDraggedItems] = useState([]);
  const [droppedItems, setDroppedItems] = useState({});
  const [timeLeft, setTimeLeft] = useState(60);
  const [isTimerActive, setIsTimerActive] = useState(false);
  const gameContentRef = useRef(null);
  const timerRef = useRef(null);

  const translations = {
    en: {
      mainTitle: "Human Body Biology Game",
      subtitle: "рооройро┐род роЙроЯро▓рпН роЙропро┐ро░ро┐ропро▓рпН ро╡ро┐ро│рпИропро╛роЯрпНроЯрпБ",
      selectLevel: "Select Your Learning Level",
      beginnerTitle: "ЁЯФм Beginner (Ages 6-8)",
      beginnerDesc: "Learn about human cells and their parts through fun drag-and-drop activities!",
      mediumTitle: "ЁЯлА Medium (Ages 9-10)",
      mediumDesc: "Explore body systems and match organs with their functions!",
      advancedTitle: "ЁЯза Advanced (Ages 11-12)",
      advancedDesc: "Master complex human biology concepts and processes!",
      backBtn: "тЖР Back to Levels",
      scoreLabel: "Score:",
      timeLabel: "Time:",
      congratsTitle: "ЁЯОЙ Congratulations! ЁЯОЙ",
      congratsMessage: "You've completed all questions successfully!",
      finalScore: "Final Score:",
      tryAgain: "Try Another Level",
      playAgain: "Play Again",
      dragItems: "Drag Items:",
      dropHere: "Drop Here:",
      correct: "Correct! Well done! ЁЯОЙ",
      incorrect: "Try again! You can do it! ЁЯТк",
      excellent: "Excellent work! ЁЯМЯ",
      keepTrying: "Keep trying! ЁЯОп",
      nextQuestion: "Next Question тЖТ",
      correctAnswers: "Correct answers:",
      timeUp: "Time's up! тП░",
      seconds: "seconds"
    },
    ta: {
      mainTitle: "рооройро┐род роЙроЯро▓рпН роЙропро┐ро░ро┐ропро▓рпН ро╡ро┐ро│рпИропро╛роЯрпНроЯрпБ",
      subtitle: "Human Body Biology Game",
      selectLevel: "роЙроЩрпНроХро│рпН роХро▒рпНро▒ро▓рпН роиро┐ро▓рпИропрпИродрпН родрпЗро░рпНроирпНродрпЖроЯрпБроХрпНроХро╡рпБроорпН",
      beginnerTitle: "ЁЯФм родрпКроЯроХрпНроХ роиро┐ро▓рпИ (ро╡ропродрпБ 6-8)",
      beginnerDesc: "рооройро┐род роЪрпЖро▓рпНроХро│рпН рооро▒рпНро▒рпБроорпН роЕро╡ро▒рпНро▒ро┐ройрпН рокроХрпБродро┐роХро│рпИрокрпН рокро▒рпНро▒ро┐ ро╡рпЗроЯро┐роХрпНроХрпИропро╛рой роЗро┤рпБродрпНродрпБ ро╡ро┐роЯрпБроорпН роЪрпЖропро▓рпНрокро╛роЯрпБроХро│рпН роорпВро▓роорпН роЕро▒ро┐ропрпБроЩрпНроХро│рпН!",
      mediumTitle: "ЁЯлА роироЯрпБродрпНродро░ роиро┐ро▓рпИ (ро╡ропродрпБ 9-10)",
      mediumDesc: "роЙроЯро▓рпН роЕроорпИрокрпНрокрпБроХро│рпИ роЖро░ро╛ропрпНроирпНродрпБ роЙро▒рпБрокрпНрокрпБроХро│рпИ роЕро╡ро▒рпНро▒ро┐ройрпН роЪрпЖропро▓рпНрокро╛роЯрпБроХро│рпБроЯройрпН рокрпКро░рпБродрпНродрпБроЩрпНроХро│рпН!",
      advancedTitle: "ЁЯза роорпЗроорпНрокроЯрпНроЯ роиро┐ро▓рпИ (ро╡ропродрпБ 11-12)",
      advancedDesc: "роЪро┐роХрпНроХро▓ро╛рой рооройро┐род роЙропро┐ро░ро┐ропро▓рпН роХро░рпБродрпНродрпБроХрпНроХро│рпН рооро▒рпНро▒рпБроорпН роЪрпЖропро▓рпНроорпБро▒рпИроХро│ро┐ро▓рпН родрпЗро░рпНроЪрпНроЪро┐ рокрпЖро▒рпБроЩрпНроХро│рпН!",
      backBtn: "тЖР роиро┐ро▓рпИроХро│рпБроХрпНроХрпБродрпН родро┐ро░рпБроорпНрокрпБ",
      scoreLabel: "роородро┐рокрпНрокрпЖрогрпН:",
      timeLabel: "роирпЗро░роорпН:",
      congratsTitle: "ЁЯОЙ ро╡ро╛ро┤рпНродрпНродрпБроХрпНроХро│рпН! ЁЯОЙ",
      congratsMessage: "роирпАроЩрпНроХро│рпН роОро▓рпНро▓ро╛ роХрпЗро│рпНро╡ро┐роХро│рпИропрпБроорпН ро╡рпЖро▒рпНро▒ро┐роХро░рооро╛роХ роорпБроЯро┐родрпНродрпБро╡ро┐роЯрпНроЯрпАро░рпНроХро│рпН!",
      finalScore: "роЗро▒рпБродро┐ роородро┐рокрпНрокрпЖрогрпН:",
      tryAgain: "ро╡рпЗро▒рпБ роиро┐ро▓рпИропрпИ роорпБропро▒рпНроЪро┐роХрпНроХро╡рпБроорпН",
      playAgain: "роорпАрогрпНроЯрпБроорпН ро╡ро┐ро│рпИропро╛роЯрпБ",
      dragItems: "рокрпКро░рпБроЯрпНроХро│рпИ роЗро┤рпБроХрпНроХро╡рпБроорпН:",
      dropHere: "роЗроЩрпНроХрпЗ ро╡ро┐роЯро╡рпБроорпН:",
      correct: "роЪро░ро┐! роиройрпНро▒ро╛роХ роЪрпЖропрпНродрпАро░рпНроХро│рпН! ЁЯОЙ",
      incorrect: "роорпАрогрпНроЯрпБроорпН роорпБропро▒рпНроЪро┐роХрпНроХро╡рпБроорпН! роирпАроЩрпНроХро│рпН роЪрпЖропрпНропро▓ро╛роорпН! ЁЯТк",
      excellent: "роЪро┐ро▒роирпНрод ро╡рпЗро▓рпИ! ЁЯМЯ",
      keepTrying: "роорпБропро▒рпНроЪро┐ роЪрпЖропрпНродрпБ роХрпКрогрпНроЯрпЗ роЗро░рпБроЩрпНроХро│рпН! ЁЯОп",
      nextQuestion: "роЕроЯрпБродрпНрод роХрпЗро│рпНро╡ро┐ тЖТ",
      correctAnswers: "роЪро░ро┐ропро╛рой рокродро┐ро▓рпНроХро│рпН:",
      timeUp: "роирпЗро░роорпН роорпБроЯро┐роирпНродродрпБ! тП░",
      seconds: "ро╡ро┐ройро╛роЯро┐роХро│рпН"
    }
  };

  // Questions data (kept as you provided; add/edit if you want more)
  const questionData = {
    beginner: [
      {
        en: {
          question: "Drag the cell parts to their correct positions in the human cell:",
          items: ["Nucleus", "Cell Membrane", "Cytoplasm", "Mitochondria"],
          targets: ["Controls the cell", "Protects the cell", "Jelly-like substance", "Powerhouse of cell"],
          pairs: [
            ["Nucleus", "Controls the cell"],
            ["Cell Membrane", "Protects the cell"],
            ["Cytoplasm", "Jelly-like substance"],
            ["Mitochondria", "Powerhouse of cell"]
          ]
        },
        ta: {
          question: "роЪрпЖро▓рпН рокро╛роХроЩрпНроХро│рпИ рооройро┐род роЪрпЖро▓рпНро▓ро┐ро▓рпН роЕро╡ро▒рпНро▒ро┐ройрпН роЪро░ро┐ропро╛рой роЗроЯроЩрпНроХро│рпБроХрпНроХрпБ роЗро┤рпБроХрпНроХро╡рпБроорпН:",
          items: ["роХро░рпБро╡роорпН", "роЪрпЖро▓рпН роЪрпБро╡ро░рпН", "роХро▓роорпН", "роорпИроЯрпНроЯрпЛроХро╛рогрпНроЯрпНро░ро┐ропро╛"],
          targets: ["роЪрпЖро▓рпНро▓рпИроХрпН роХроЯрпНроЯрпБрокрпНрокроЯрпБродрпНродрпБроХро┐ро▒родрпБ", "роЪрпЖро▓рпНро▓рпИрокрпН рокро╛родрпБроХро╛роХрпНроХро┐ро▒родрпБ", "роЬрпЖро▓рпНро▓ро┐ рокрпЛройрпНро▒ рокрпКро░рпБро│рпН", "роЪрпЖро▓рпНро▓ро┐ройрпН роЪроХрпНродро┐ роорпИропроорпН"],
          pairs: [
            ["роХро░рпБро╡роорпН", "роЪрпЖро▓рпНро▓рпИроХрпН роХроЯрпНроЯрпБрокрпНрокроЯрпБродрпНродрпБроХро┐ро▒родрпБ"],
            ["роЪрпЖро▓рпН роЪрпБро╡ро░рпН", "роЪрпЖро▓рпНро▓рпИрокрпН рокро╛родрпБроХро╛роХрпНроХро┐ро▒родрпБ"],
            ["роХро▓роорпН", "роЬрпЖро▓рпНро▓ро┐ рокрпЛройрпНро▒ рокрпКро░рпБро│рпН"],
            ["роорпИроЯрпНроЯрпЛроХро╛рогрпНроЯрпНро░ро┐ропро╛", "роЪрпЖро▓рпНро▓ро┐ройрпН роЪроХрпНродро┐ роорпИропроорпН"]
          ]
        }
      },
      {
        en: {
          question: "Match the blood cell types with their functions:",
          items: ["Red Blood Cells", "White Blood Cells", "Platelets", "Plasma"],
          targets: ["Carry oxygen", "Fight germs", "Help blood clot", "Liquid part of blood"],
          pairs: [
            ["Red Blood Cells", "Carry oxygen"],
            ["White Blood Cells", "Fight germs"],
            ["Platelets", "Help blood clot"],
            ["Plasma", "Liquid part of blood"]
          ]
        },
        ta: {
          question: "роЗро░родрпНрод роЪрпЖро▓рпН ро╡роХрпИроХро│рпИ роЕро╡ро▒рпНро▒ро┐ройрпН роЪрпЖропро▓рпНрокро╛роЯрпБроХро│рпБроЯройрпН рокрпКро░рпБродрпНродрпБроЩрпНроХро│рпН:",
          items: ["роЪро┐ро╡рокрпНрокрпБ роЗро░родрпНрод роЕрогрпБроХрпНроХро│рпН", "ро╡рпЖро│рпНро│рпИ роЗро░родрпНрод роЕрогрпБроХрпНроХро│рпН", "рокро┐ро│рпЗроЯрпНро▓рпЖроЯрпНроЯрпБроХро│рпН", "рокро┐ро│ро╛ро╕рпНрооро╛"],
          targets: ["роЖроХрпНро╕ро┐роЬройрпИ роОроЯрпБродрпНродрпБроЪрпН роЪрпЖро▓рпНроХро┐ро▒родрпБ", "роХро┐ро░рпБрооро┐роХро│рпИ роОродро┐ро░рпНродрпНродрпБрокрпН рокрпЛро░ро╛роЯрпБроХро┐ро▒родрпБ", "роЗро░родрпНродроорпН роЙро▒рпИроп роЙродро╡рпБроХро┐ро▒родрпБ", "роЗро░родрпНродродрпНродро┐ройрпН родро┐ро░ро╡ рокроХрпБродро┐"],
          pairs: [
            ["роЪро┐ро╡рокрпНрокрпБ роЗро░родрпНрод роЕрогрпБроХрпНроХро│рпН", "роЖроХрпНро╕ро┐роЬройрпИ роОроЯрпБродрпНродрпБроЪрпН роЪрпЖро▓рпНроХро┐ро▒родрпБ"],
            ["ро╡рпЖро│рпНро│рпИ роЗро░родрпНрод роЕрогрпБроХрпНроХро│рпН", "роХро┐ро░рпБрооро┐роХро│рпИ роОродро┐ро░рпНродрпНродрпБрокрпН рокрпЛро░ро╛роЯрпБроХро┐ро▒родрпБ"],
            ["рокро┐ро│рпЗроЯрпНро▓рпЖроЯрпНроЯрпБроХро│рпН", "роЗро░родрпНродроорпН роЙро▒рпИроп роЙродро╡рпБроХро┐ро▒родрпБ"],
            ["рокро┐ро│ро╛ро╕рпНрооро╛", "роЗро░родрпНродродрпНродро┐ройрпН родро┐ро░ро╡ рокроХрпБродро┐"]
          ]
        }
      }
    ],
    medium: [
      {
        en: {
          question: "Match the body systems with their main organs:",
          items: ["Heart", "Lungs", "Brain", "Stomach"],
          targets: ["Circulatory System", "Respiratory System", "Nervous System", "Digestive System"],
          pairs: [
            ["Heart", "Circulatory System"],
            ["Lungs", "Respiratory System"],
            ["Brain", "Nervous System"],
            ["Stomach", "Digestive System"]
          ]
        },
        ta: {
          question: "роЙроЯро▓рпН роЕроорпИрокрпНрокрпБроХро│рпИ роЕро╡ро▒рпНро▒ро┐ройрпН роорпБроХрпНроХро┐роп роЙро▒рпБрокрпНрокрпБроХро│рпБроЯройрпН рокрпКро░рпБродрпНродрпБроЩрпНроХро│рпН:",
          items: ["роЗродропроорпН", "роирпБро░рпИропрпАро░ро▓рпН", "роорпВро│рпИ", "ро╡ропро┐ро▒рпБ"],
          targets: ["роЗро░родрпНрод роУроЯрпНроЯ роЕроорпИрокрпНрокрпБ", "роЪрпБро╡ро╛роЪ роЕроорпИрокрпНрокрпБ", "роиро░роорпНрокрпБ роЕроорпИрокрпНрокрпБ", "роЪрпЖро░ро┐рооро╛рой роЕроорпИрокрпНрокрпБ"],
          pairs: [
            ["роЗродропроорпН", "роЗро░родрпНрод роУроЯрпНроЯ роЕроорпИрокрпНрокрпБ"],
            ["роирпБро░рпИропрпАро░ро▓рпН", "роЪрпБро╡ро╛роЪ роЕроорпИрокрпНрокрпБ"],
            ["роорпВро│рпИ", "роиро░роорпНрокрпБ роЕроорпИрокрпНрокрпБ"],
            ["ро╡ропро┐ро▒рпБ", "роЪрпЖро░ро┐рооро╛рой роЕроорпИрокрпНрокрпБ"]
          ]
        }
      },
      {
        en: {
          question: "Match the organs with their primary functions:",
          items: ["Kidneys", "Liver", "Skin", "Bones"],
          targets: ["Filter waste from blood", "Process nutrients", "Protect body", "Support body structure"],
          pairs: [
            ["Kidneys", "Filter waste from blood"],
            ["Liver", "Process nutrients"],
            ["Skin", "Protect body"],
            ["Bones", "Support body structure"]
          ]
        },
        ta: {
          question: "роЙро▒рпБрокрпНрокрпБроХро│рпИ роЕро╡ро▒рпНро▒ро┐ройрпН роорпБродройрпНроорпИ роЪрпЖропро▓рпНрокро╛роЯрпБроХро│рпБроЯройрпН рокрпКро░рпБродрпНродрпБроЩрпНроХро│рпН:",
          items: ["роЪро┐ро▒рпБроирпАро░роХроЩрпНроХро│рпН", "роХро▓рпНро▓рпАро░ро▓рпН", "родрпЛро▓рпН", "роОро▓рпБроорпНрокрпБроХро│рпН"],
          targets: ["роЗро░родрпНродродрпНродро┐ро▓рпН роЗро░рпБроирпНродрпБ роХро┤ро┐ро╡рпБроХро│рпИ ро╡роЯро┐роХроЯрпНроЯрпБроХро┐ро▒родрпБ", "роКроЯрпНроЯроЪрпНроЪродрпНродрпБроХрпНроХро│рпИ роЪрпЖропро▓ро╛роХрпНроХрпБроХро┐ро▒родрпБ", "роЙроЯро▓рпИрокрпН рокро╛родрпБроХро╛роХрпНроХро┐ро▒родрпБ", "роЙроЯро▓рпН роЕроорпИрокрпНрокрпИ роЖродро░ро┐роХрпНроХро┐ро▒родрпБ"],
          pairs: [
            ["роЪро┐ро▒рпБроирпАро░роХроЩрпНроХро│рпН", "роЗро░родрпНродродрпНродро┐ро▓рпН роЗро░рпБроирпНродрпБ роХро┤ро┐ро╡рпБроХро│рпИ ро╡роЯро┐роХроЯрпНроЯрпБроХро┐ро▒родрпБ"],
            ["роХро▓рпНро▓рпАро░ро▓рпН", "роКроЯрпНроЯроЪрпНроЪродрпНродрпБроХрпНроХро│рпИ роЪрпЖропро▓ро╛роХрпНроХрпБроХро┐ро▒родрпБ"],
            ["родрпЛро▓рпН", "роЙроЯро▓рпИрокрпН рокро╛родрпБроХро╛роХрпНроХро┐ро▒родрпБ"],
            ["роОро▓рпБроорпНрокрпБроХро│рпН", "роЙроЯро▓рпН роЕроорпИрокрпНрокрпИ роЖродро░ро┐роХрпНроХро┐ро▒родрпБ"]
          ]
        }
      }
    ],
    advanced: [
      {
        en: {
          question: "Match the biological processes with their descriptions:",
          items: ["Photosynthesis", "Cellular Respiration", "Protein Synthesis", "DNA Replication"],
          targets: ["Energy production in cells", "Making copies of genetic material", "Creating proteins from DNA", "Converting light to chemical energy"],
          pairs: [
            ["Cellular Respiration", "Energy production in cells"],
            ["DNA Replication", "Making copies of genetic material"],
            ["Protein Synthesis", "Creating proteins from DNA"],
            ["Photosynthesis", "Converting light to chemical energy"]
          ]
        },
        ta: {
          question: "роЙропро┐ро░ро┐ропро▓рпН роЪрпЖропро▓рпНроорпБро▒рпИроХро│рпИ роЕро╡ро▒рпНро▒ро┐ройрпН ро╡ро┐ро│роХрпНроХроЩрпНроХро│рпБроЯройрпН рокрпКро░рпБродрпНродрпБроЩрпНроХро│рпН:",
          items: ["роТро│ро┐роЪрпНроЪрпЗро░рпНроХрпНроХрпИ", "роЪрпЖро▓рпН роЪрпБро╡ро╛роЪроорпН", "рокрпБро░род родрпКроХрпБрокрпНрокрпБ", "DNA роироХро▓рпЖроЯрпБродрпНродро▓рпН"],
          targets: ["роЪрпЖро▓рпНроХро│ро┐ро▓рпН роЖро▒рпНро▒ро▓рпН роЙро▒рпНрокродрпНродро┐", "рооро░рокрпБрокрпН рокрпКро░рпБро│ро┐ройрпН роироХро▓рпНроХро│рпИ роЙро░рпБро╡ро╛роХрпНроХрпБродро▓рпН", "DNA роЗро▓ро┐ро░рпБроирпНродрпБ рокрпБро░родроЩрпНроХро│рпИ роЙро░рпБро╡ро╛роХрпНроХрпБродро▓рпН", "роТро│ро┐ропрпИ ро╡рпЗродро┐ропро┐ропро▓рпН роЖро▒рпНро▒ро▓ро╛роХ рооро╛ро▒рпНро▒рпБродро▓рпН"],
          pairs: [
            ["роЪрпЖро▓рпН роЪрпБро╡ро╛роЪроорпН", "роЪрпЖро▓рпНроХро│ро┐ро▓рпН роЖро▒рпНро▒ро┐ роЙро▒рпНрокродрпНродро┐"],
            ["DNA роироХро▓рпЖроЯрпБродрпНродро▓рпН", "рооро░рокрпБрокрпН рокрпКро░рпБро│ро┐ройрпН роироХро▓рпНроХро│рпИ роЙро░рпБро╡ро╛роХрпНроХрпБродро▓рпН"],
            ["рокрпБро░род родрпКроХрпБрокрпНрокрпБ", "DNA роЗро▓ро┐ро░рпБроирпНродрпБ рокрпБро░родроЩрпНроХро│рпИ роЙро░рпБро╡ро╛роХрпНроХрпБродро▓рпН"],
            ["роТро│ро┐роЪрпНроЪрпЗро░рпНроХрпНроХрпИ", "роТро│ро┐ропрпИ ро╡рпЗродро┐ропро┐ропро▓рпН роЖро▒рпНро▒ро▓ро╛роХ рооро╛ро▒рпНро▒рпБродро▓рпН"]
          ]
        }
      },
      {
        en: {
          question: "Match the hormones with their functions:",
          items: ["Insulin", "Adrenaline", "Growth Hormone", "Thyroid Hormone"],
          targets: ["Regulates blood sugar", "Fight or flight response", "Controls body growth", "Regulates metabolism"],
          pairs: [
            ["Insulin", "Regulates blood sugar"],
            ["Adrenaline", "Fight or flight response"],
            ["Growth Hormone", "Controls body growth"],
            ["Thyroid Hormone", "Regulates metabolism"]
          ]
        },
        ta: {
          question: "ро╣ро╛ро░рпНроорпЛройрпНроХро│рпИ роЕро╡ро▒рпНро▒ро┐ройрпН роЪрпЖропро▓рпНрокро╛роЯрпБроХро│рпБроЯройрпН рокрпКро░рпБродрпНродрпБроЩрпНроХро│рпН:",
          items: ["роЗройрпНроЪрпБро▓ро┐ройрпН", "роЕроЯрпНро░ро┐ройро▓ро┐ройрпН", "ро╡ро│ро░рпНроЪрпНроЪро┐ ро╣ро╛ро░рпНроорпЛройрпН", "родрпИро░ро╛ропрпНроЯрпБ ро╣ро╛ро░рпНроорпЛройрпН"],
          targets: ["роЗро░родрпНрод роЪро░рпНроХрпНроХро░рпИропрпИ роХроЯрпНроЯрпБрокрпНрокроЯрпБродрпНродрпБроХро┐ро▒родрпБ", "роЪрогрпНроЯрпИ роЕро▓рпНро▓родрпБ роУроЯрпНроЯроорпН рокродро┐ро▓рпН", "роЙроЯро▓рпН ро╡ро│ро░рпНроЪрпНроЪро┐ропрпИроХрпН роХроЯрпНроЯрпБрокрпНрокроЯрпБродрпНродрпБроХро┐ро▒родрпБ", "ро╡ро│ро░рпНроЪро┐родрпИ рооро╛ро▒рпНро▒родрпНродрпИроХрпН роХроЯрпНроЯрпБрокрпНрокроЯрпБродрпНродрпБроХро┐ро▒родрпБ"],
          pairs: [
            ["роЗройрпНроЪрпБро▓ро┐ройрпН", "роЗро░родрпНрод роЪро░рпНроХрпНроХро░рпИропрпИ роХроЯрпНроЯрпБрокрпНрокроЯрпБродрпНродрпБроХро┐ро▒родрпБ"],
            ["роЕроЯрпНро░ро┐ройро▓ро┐ройрпН", "роЪрогрпНроЯрпИ роЕро▓рпНро▓родрпБ роУроЯрпНроЯроорпН рокродро┐ро▓рпН"],
            ["ро╡ро│ро░рпНроЪрпНроЪро┐ ро╣ро╛ро░рпНроорпЛройрпН", "роЙроЯро▓рпН ро╡ро│ро░рпНроЪрпНроЪро┐ропрпИроХрпН роХроЯрпНроЯрпБрокрпНрокроЯрпБродрпНродрпБроХро┐ро▒родрпБ"],
            ["родрпИро░ро╛ропрпНроЯрпБ ро╣ро╛ро░рпНроорпЛройрпН", "ро╡ро│ро░рпНроЪро┐родрпИ рооро╛ро▒рпНро▒родрпНродрпИроХрпН роХроЯрпНроЯрпБрокрпНрокроЯрпБродрпНродрпБроХро┐ро▒родрпБ"]
          ]
        }
      }
    ]
  };

  // Shuffle helper
  const shuffleArray = (array) => {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  };

  // Timer logic (per-question timer)
  useEffect(() => {
    if (isTimerActive && timeLeft > 0) {
      timerRef.current = setTimeout(() => {
        setTimeLeft(prev => prev - 1);
      }, 1000);
    } else if (timeLeft === 0 && isTimerActive) {
      setIsTimerActive(false);
      setFeedback({
        show: true,
        type: 'timeout',
        message: translations[currentLanguage].timeUp
      });
    }

    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    };
  }, [timeLeft, isTimerActive, currentLanguage]);

  // Confetti creators (simple DOM confetti)
  const createConfetti = () => {
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3'];
    for (let i = 0; i < 50; i++) {
      const confetti = document.createElement('div');
      confetti.className = 'confetti';
      confetti.style.left = Math.random() * 100 + 'vw';
      confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.animationDelay = Math.random() * 3 + 's';
      confetti.style.animationDuration = Math.random() * 3 + 2 + 's';
      document.body.appendChild(confetti);
      setTimeout(() => {
        if (confetti.parentNode) confetti.parentNode.removeChild(confetti);
      }, 5000);
    }
  };

  const createCorrectAnswerConfetti = () => {
    const colors = ['#00b894', '#00cec9', '#74b9ff'];
    for (let i = 0; i < 20; i++) {
      const confetti = document.createElement('div');
      confetti.className = 'mini-confetti';
      confetti.style.left = Math.random() * 100 + 'vw';
      confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.animationDelay = Math.random() * 0.5 + 's';
      document.body.appendChild(confetti);
      setTimeout(() => {
        if (confetti.parentNode) confetti.parentNode.removeChild(confetti);
      }, 2000);
    }
  };

  const createQuestionConfetti = () => {
    const colors = ['#ffeaa7', '#fab1a0', '#fd79a8', '#a29bfe'];
    for (let i = 0; i < 30; i++) {
      const confetti = document.createElement('div');
      confetti.className = 'question-confetti';
      confetti.style.left = Math.random() * 100 + 'vw';
      confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.animationDelay = Math.random() * 1 + 's';
      document.body.appendChild(confetti);
      setTimeout(() => {
        if (confetti.parentNode) confetti.parentNode.removeChild(confetti);
      }, 3000);
    }
  };

  const handleLanguageChange = (lang) => {
    setCurrentLanguage(lang);
  };

  // Start level: set questions, reset indices, shuffle first question items
  const startLevel = (level) => {
    setCurrentLevel(level);
    setCurrentQuestionIndex(0);
    setScore(0);
    setQuestions(questionData[level]);
    setShowGameArea(true);
    setFeedback({ show: false, type: '', message: '' });
    setTimeLeft(60);
    setIsTimerActive(true);

    // Initialize drag state for first question (use selected language)
    // Guard in case data missing
    const firstQ = questionData[level] && questionData[level][0] && questionData[level][0][currentLanguage];
    if (firstQ) {
      setDraggedItems(shuffleArray(firstQ.items));
    } else {
      setDraggedItems([]);
    }
    setDroppedItems({});
    setShowCelebration(false);
  };

  // Load question when index changes or when game area first shown
  const loadQuestion = () => {
    if (!questions || questions.length === 0) return;

    if (currentQuestionIndex >= questions.length) {
      // Completed all questions
      setShowCelebration(true);
      setIsTimerActive(false);
      createConfetti();
      return;
    }

    const questionObj = questions[currentQuestionIndex][currentLanguage];
    if (questionObj) {
      setDraggedItems(shuffleArray(questionObj.items));
      setDroppedItems({});
      setFeedback({ show: false, type: '', message: '' });
      setTimeLeft(30); // per-question timer reset
      setIsTimerActive(true);
    }
  };

  useEffect(() => {
    if (showGameArea && questions.length > 0) {
      loadQuestion();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentQuestionIndex, showGameArea]);

  // When language changes, update the currently loaded question display
  useEffect(() => {
    if (showGameArea && questions.length > 0 && currentQuestionIndex < questions.length) {
      const questionObj = questions[currentQuestionIndex][currentLanguage];
      if (questionObj) {
        setDraggedItems(shuffleArray(questionObj.items));
        setDroppedItems({});
        setFeedback({ show: false, type: '', message: '' });
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentLanguage]);

  // Drag handlers
  const handleDragStart = (e, item) => {
    e.dataTransfer.setData('text/plain', item);
    e.target.classList.add('dragging');
  };

  const handleDragEnd = (e) => {
    e.target.classList.remove('dragging');
  };

  const handleDragOver = (e) => {
    e.preventDefault();
    e.currentTarget.classList.add('drag-over');
  };

  const handleDragLeave = (e) => {
    e.currentTarget.classList.remove('drag-over');
  };

  // Drop handler: places the dragged item onto the target and checks correctness
  const handleDrop = (e, target) => {
    e.preventDefault();
    e.currentTarget.classList.remove('drag-over');
    const draggedItem = e.dataTransfer.getData('text/plain');

    // Update dropped items immutably
    const previousItem = droppedItems[target];
    const newDropped = { ...droppedItems, [target]: draggedItem };
    setDroppedItems(newDropped);

    // Update draggable list: remove dragged item, add previous item back if any
    let newDragged = draggedItems.filter(item => item !== draggedItem);
    if (previousItem) newDragged.push(previousItem);
    setDraggedItems(newDragged);

    // Check correctness for mini confetti
    const questionObj = questions[currentQuestionIndex][currentLanguage];
    const isCorrect = questionObj.pairs.some(pair => pair[0] === draggedItem && pair[1] === target);
    if (isCorrect) createCorrectAnswerConfetti();

    // Small delay to let state settle, then evaluate all answers
    setTimeout(() => checkAllAnswers(newDropped), 100);
  };

  // Evaluate all answers for the current question
  const checkAllAnswers = (currentDroppedItems = droppedItems) => {
    if (!questions || questions.length === 0) return;
    const questionObj = questions[currentQuestionIndex][currentLanguage];
    if (!questionObj) return;

    let correctCount = 0;
    let totalAnswered = 0;

    questionObj.targets.forEach(target => {
      const droppedItem = currentDroppedItems[target];
      if (droppedItem) {
        totalAnswered++;
        const isCorrect = questionObj.pairs.some(pair => pair[0] === droppedItem && pair[1] === target);
        if (isCorrect) correctCount++;
      }
    });

    if (totalAnswered === questionObj.items.length) {
      if (correctCount === questionObj.items.length) {
        // All correct
        setScore(prev => prev + 1);
        setIsTimerActive(false);
        createQuestionConfetti();
        setFeedback({ show: true, type: 'success', message: translations[currentLanguage].excellent });
      } else {
        setFeedback({
          show: true,
          type: 'error',
          message: `${translations[currentLanguage].keepTrying} ${translations[currentLanguage].correctAnswers} ${correctCount}/${questionObj.items.length}`
        });
      }
    }
  };

  // Next question button - robustly reset state and advance index
  const nextQuestion = () => {
    // Clear feedback and dropped items for visual reset
    setFeedback({ show: false, type: '', message: '' });
    setDroppedItems({});
    setIsTimerActive(false);

    // If next index would go past last question show celebration
    if (currentQuestionIndex + 1 >= questions.length) {
      setShowCelebration(true);
      setIsTimerActive(false);
      createConfetti();
      return;
    }

    // Advance index using functional update
    setCurrentQuestionIndex(prev => {
      const newIndex = prev + 1;
      // prepare dragged items for new question immediately
      const nextQ = questions[newIndex] && questions[newIndex][currentLanguage];
      if (nextQ) {
        setDraggedItems(shuffleArray(nextQ.items));
        setTimeLeft(30);
        setIsTimerActive(true);
      } else {
        setDraggedItems([]);
      }
      return newIndex;
    });
  };

  // Back to level selection
  const goBack = () => {
    setShowGameArea(false);
    setShowCelebration(false);
    setCurrentLevel('');
    setCurrentQuestionIndex(0);
    setScore(0);
    setFeedback({ show: false, type: '', message: '' });
    setIsTimerActive(false);
    setTimeLeft(60);
    setDraggedItems([]);
    setDroppedItems({});
  };

  // Restart current level from beginning
  const restartLevel = () => {
    setShowCelebration(false);
    if (currentLevel) startLevel(currentLevel);
  };

  const t = translations[currentLanguage];
  const currentQuestion = showGameArea && questions.length > 0 && currentQuestionIndex < questions.length
    ? questions[currentQuestionIndex][currentLanguage]
    : null;

  return (
    <div className="biology-container">
      <div className="biology-header">
        <h1>{t.mainTitle}</h1>
        <p>{t.subtitle}</p>
        <div className="language-toggle">
          <button
            className={'language-btn ' + (currentLanguage === 'en' ? 'active' : '')}
            onClick={() => handleLanguageChange('en')}
          >
            English
          </button>
          <button
            className={'language-btn ' + (currentLanguage === 'ta' ? 'active' : '')}
            onClick={() => handleLanguageChange('ta')}
          >
            родрооро┐ро┤рпН
          </button>
        </div>
      </div>

      {!showGameArea && (
        <div className="level-selection">
          <h2>{t.selectLevel}</h2>

          {/* CENTERED LEVEL CARDS */}
          <div className="level-grid">
            <div className="level-card" onClick={() => startLevel('beginner')}>
              <h3>{t.beginnerTitle}</h3>
              <p>{t.beginnerDesc}</p>
            </div>
            <div className="level-card" onClick={() => startLevel('medium')}>
              <h3>{t.mediumTitle}</h3>
              <p>{t.mediumDesc}</p>
            </div>
            <div className="level-card" onClick={() => startLevel('advanced')}>
              <h3>{t.advancedTitle}</h3>
              <p>{t.advancedDesc}</p>
            </div>
          </div>
        </div>
      )}

      {showGameArea && (
        <div className="game-area">
          <div className="game-header">
            <button className="back-btn" onClick={goBack}>
              {t.backBtn}
            </button>
            <div className="game-stats">
              <div className="score">
                {t.scoreLabel} {score}/{questions.length}
              </div>
              <div className={'timer ' + (timeLeft <= 10 && isTimerActive ? 'timer-warning' : '')}>
                {t.timeLabel} {timeLeft} {t.seconds}
              </div>
            </div>
          </div>

          <div className="question-area">
            <div className="question">
              <div className="question-progress">
                Question {currentQuestionIndex + 1} of {questions.length}
              </div>
              <h3>{currentQuestion?.question}</h3>
            </div>

            <div className="drag-area" ref={gameContentRef}>
              <div className="draggables">
                <h4>{t.dragItems}</h4>
                <div className="drag-items">
                  {draggedItems.map((item, index) => (
                    <div
                      key={item + '-' + index}
                      className="drag-item"
                      draggable
                      onDragStart={(e) => handleDragStart(e, item)}
                      onDragEnd={handleDragEnd}
                    >
                      {item}
                    </div>
                  ))}
                </div>
              </div>

              <div className="drop-zones">
                <h4>{t.dropHere}</h4>
                {currentQuestion?.targets.map((target) => {
                  const droppedItem = droppedItems[target];
                  const questionObj = questions[currentQuestionIndex][currentLanguage];
                  const isCorrect = droppedItem && questionObj.pairs.some(pair =>
                    pair[0] === droppedItem && pair[1] === target
                  );
                  const isIncorrect = droppedItem && !isCorrect;

                  return (
                    <div
                      key={target}
                      className={
                        'drop-zone' + (isCorrect ? ' correct' : '') + (isIncorrect ? ' incorrect' : '')
                      }
                      onDragOver={handleDragOver}
                      onDragLeave={handleDragLeave}
                      onDrop={(e) => handleDrop(e, target)}
                    >
                      <span>{target}</span>
                      <span className="dropped-item">
                        {droppedItem || ''}
                      </span>
                    </div>
                  );
                })}
              </div>
            </div>

            {feedback.show && (
              <div className={"feedback " + feedback.type}>
                <div>{feedback.message}</div>
                <button
                  className="celebration-btn"
                  onClick={nextQuestion}
                  style={{ marginTop: '15px' }}
                >
                  {t.nextQuestion}
                </button>
              </div>
            )}
          </div>
        </div>
      )}

      {showCelebration && (
        <div className="celebration">
          <div className="celebration-content">
            <h2>{t.congratsTitle}</h2>
            <p>{t.congratsMessage}</p>
            <p>{t.finalScore} {score}/{questions.length}</p>
            <button className="celebration-btn" onClick={goBack}>
              {t.tryAgain}
            </button>
            <button className="celebration-btn" onClick={restartLevel}>
              {t.playAgain}
            </button>
          </div>
        </div>
      )}

      {/* All CSS kept here as requested */}
      <style>{`
        * { margin:0; padding:0; box-sizing:border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 10px; overflow-x: hidden; display:flex; align-items:center; justify-content:center; }
        .biology-container { max-width:1200px; width:100%; min-height:90vh; max-height:95vh; background:white; border-radius:20px; box-shadow:0 20px 40px rgba(0,0,0,0.1); overflow:hidden; display:flex; flex-direction:column; }
        .biology-header { background: linear-gradient(135deg, #ff6b6b, #ee5a24); color:white; text-align:center; padding:18px; flex-shrink:0; }
        .biology-header h1 { font-size: clamp(1.8rem, 4vw, 2.4rem); margin-bottom:6px; text-shadow: 2px 2px 4px rgba(0,0,0,0.2); }
        .language-toggle { margin-top:10px; }
        .language-btn { background: rgba(255,255,255,0.2); border: 2px solid white; color: white; padding:6px 12px; margin:0 4px; border-radius:20px; cursor:pointer; transition:all .25s ease; font-size:12px; }
        .language-btn.active { background:white; color:#ff6b6b; }
        .level-selection { padding:20px; text-align:center; flex:1; display:flex; flex-direction:column; justify-content:center; overflow-y:auto; }
        .level-selection h2 { font-size: clamp(1.5rem, 3.5vw, 2rem); color:#2d3436; margin-bottom:18px; }
        /* centered layout for levels */
        .level-grid { display:flex; gap:18px; justify-content:center; align-items:stretch; flex-wrap:wrap; max-width:920px; margin:0 auto; padding: 0 10px; }
        .level-card { background: linear-gradient(135deg, #74b9ff, #0984e3); color:white; padding:18px; border-radius:15px; cursor:pointer; transition: all 0.25s ease; box-shadow: 0 8px 20px rgba(0,0,0,0.1); width: 280px; display:flex; flex-direction:column; justify-content:center; }
        .level-card:hover { transform: translateY(-4px); box-shadow: 0 12px 28px rgba(0,0,0,0.18); }
        .level-card h3 { font-size: clamp(1.1rem, 2.5vw, 1.25rem); margin-bottom:8px; }
        .level-card p { font-size: clamp(0.9rem, 2vw, 1rem); opacity:0.95; line-height:1.3; }
        .game-area { padding:20px; flex:1; display:flex; flex-direction:column; overflow-y:auto; }
        .game-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; flex-wrap:wrap; gap:10px; flex-shrink:0; }
        .back-btn { background:#6c5ce7; color:white; border:none; padding:10px 20px; border-radius:20px; cursor:pointer; transition:all .25s ease; font-size:14px; }
        .game-stats { display:flex; gap:15px; align-items:center; flex-wrap:wrap; margin-left:auto; }
        .score { background:#00b894; color:white; padding:10px 20px; border-radius:20px; font-weight:bold; font-size:14px; }
        .timer { background:#74b9ff; color:white; padding:10px 20px; border-radius:20px; font-weight:bold; font-size:14px; position:relative; overflow:hidden; transition:all .25s ease; }
        .timer::before { content:''; position:absolute; top:0; left:0; height:100%; width:100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.25), transparent); transform: translateX(-100%); animation: timerShimmer 2s infinite; }
        .timer-warning { background:#e74c3c !important; animation: timerPulse 1s infinite; }
        @keyframes timerShimmer { 0%{ transform: translateX(-100%);} 100%{ transform: translateX(100%);} }
        @keyframes timerPulse { 0%{ transform: scale(1);} 50%{ transform: scale(1.05);} 100%{ transform: scale(1);} }
        .question-area { background:#f8f9ff; border-radius:15px; padding:20px; margin-bottom:20px; flex:1; overflow-y:auto; }
        .question h3 { color:#2d3436; margin-bottom:18px; font-size: clamp(1.05rem, 2.5vw, 1.2rem); line-height:1.4; }
        .question-progress { background: rgba(116,185,255,0.18); color:#74b9ff; padding:6px 12px; border-radius:15px; font-size:0.8rem; font-weight:600; display:inline-block; margin-bottom:12px; }
        .drag-area { display:grid; grid-template-columns:1fr; gap:20px; margin-top:18px; }
        @media(min-width:768px){ .drag-area { grid-template-columns:1fr 1fr; gap:28px; } }
        .draggables, .drop-zones { background:white; border-radius:12px; padding:15px; box-shadow:0 4px 12px rgba(0,0,0,0.08); min-height:200px; }
        .draggables h4, .drop-zones h4 { color:#2d3436; margin-bottom:12px; text-align:center; font-size: clamp(1rem, 2vw, 1.05rem); }
        .drag-items { display:flex; flex-wrap:wrap; gap:8px; justify-content:center; }
        .drag-item { background: linear-gradient(135deg, #a29bfe, #6c5ce7); color:white; padding:8px 16px; border-radius:20px; cursor:grab; transition:all .25s ease; user-select:none; font-weight:500; font-size: clamp(0.8rem, 1.8vw, 0.9rem); box-shadow: 0 2px 8px rgba(0,0,0,0.15); position:relative; }
        .drag-item:active { cursor:grabbing; }
        .drag-item.dragging { opacity:0.5; transform: rotate(3deg) scale(1.05); }
        .drop-zone { background:#f1f2f6; border:2px dashed #ced6e0; border-radius:10px; padding:12px; margin:8px 0; min-height:50px; display:flex; align-items:center; justify-content:space-between; transition:all .25s ease; position:relative; flex-wrap:wrap; gap:8px; }
        .drop-zone:hover { background:#e9ecef; border-color:#74b9ff; }
        .drop-zone.drag-over { background:#e3f2fd; border-color:#2196f3; transform: scale(1.01); }
        .drop-zone.correct { background:#d1f2eb; border-color:#00b894; border-style:solid; animation: correctPulse 0.6s ease-out; }
        .drop-zone.incorrect { background:#fadbd8; border-color:#e74c3c; border-style:solid; animation: incorrectShake 0.5s ease-out; }
        @keyframes correctPulse { 0%{ transform: scale(1);} 50%{ transform: scale(1.05); box-shadow: 0 0 20px rgba(0,184,148,0.25);} 100%{ transform: scale(1);} }
        @keyframes incorrectShake { 0%,100%{ transform: translateX(0);} 25%{ transform: translateX(-5px);} 75%{ transform: translateX(5px);} }
        .drop-zone span:first-child { flex:1; font-weight:500; color:#2d3436; font-size: clamp(0.82rem, 1.8vw, 0.92rem); min-width:120px; }
        .dropped-item { background: linear-gradient(135deg, #00b894, #00a085); color:white; padding:6px 12px; border-radius:15px; font-weight:500; font-size: clamp(0.78rem, 1.6vw, 0.85rem); text-align:center; white-space:nowrap; }
        .drop-zone.incorrect .dropped-item { background: linear-gradient(135deg, #e74c3c, #c0392b); }
        .feedback { margin-top:15px; padding:15px; border-radius:12px; text-align:center; font-weight:600; font-size: clamp(0.9rem, 2vw, 1rem); animation: feedbackSlideIn 0.35s ease-out; }
        @keyframes feedbackSlideIn { from{ opacity:0; transform: translateY(20px);} to{ opacity:1; transform: translateY(0);} }
        .feedback.success { background:#d1f2eb; color:#00b894; border:2px solid #00b894; }
        .feedback.error { background:#fadbd8; color:#e74c3c; border:2px solid #e74c3c; }
        .feedback.timeout { background:#ffeaa7; color:#e17055; border:2px solid #e17055; }
        .next-question-btn { background: linear-gradient(135deg, #00b894, #00a085); color:white; border:none; padding:12px 24px; border-radius:20px; cursor:pointer; font-size:14px; font-weight:600; margin-top:15px; transition:all .25s ease; box-shadow: 0 4px 12px rgba(0,0,0,0.12); display:block; margin-left:auto; margin-right:auto; }
        .celebration { position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.8); z-index:1000; display:flex; justify-content:center; align-items:center; animation: fadeIn .3s ease-out; padding:20px; }
        .celebration-content { background: white; padding:30px; border-radius:20px; text-align:center; max-width:450px; width:100%; animation: celebrationPop .45s ease-out; max-height:80vh; overflow-y:auto; }
        .celebration h2 { color:#00b894; font-size: clamp(1.8rem, 4vw, 2.1rem); margin-bottom:12px; }
        .celebration p { font-size: clamp(1rem, 2.5vw, 1.05rem); margin-bottom:10px; color:#2d3436; }
        .celebration-btn { background: linear-gradient(135deg, #00b894, #00a085); color:white; border:none; padding:12px 24px; border-radius:20px; cursor:pointer; font-size: clamp(0.9rem, 2vw, 1rem); font-weight:600; margin:8px; transition:all .25s ease; box-shadow: 0 4px 12px rgba(0,0,0,0.12); }
        .confetti { position: fixed; width:8px; height:8px; z-index:1001; animation: fall linear infinite; }
        .question-confetti { position: fixed; width:6px; height:6px; z-index:999; animation: questionFall 3s linear forwards; }
        .mini-confetti { position: fixed; width:5px; height:5px; z-index:1001; animation: minifall 2s linear forwards; }
        @keyframes fadeIn { from{ opacity:0; } to{ opacity:1; } }
        @keyframes celebrationPop { 0%{ transform: scale(0.5); opacity:0; } 50%{ transform: scale(1.05);} 100%{ transform: scale(1); opacity:1;} }
        @keyframes fall { 0%{ transform: translateY(-100vh) rotate(0deg); opacity:1; } 100%{ transform: translateY(100vh) rotate(360deg); opacity:0; } }
        @keyframes questionFall { 0%{ transform: translateY(-50px) rotate(0deg); opacity:1; } 100%{ transform: translateY(150px) rotate(180deg); opacity:0; } }
        @keyframes minifall { 0%{ transform: translateY(-20px) rotate(0deg); opacity:1; } 100%{ transform: translateY(50px) rotate(180deg); opacity:0; } }

        /* responsive niceties */
        @media (max-width:768px) {
          .level-grid { gap:12px; padding:0 6px; }
          .level-card { width: 100%; max-width: 480px; }
          .game-header { flex-direction:column; align-items:stretch; text-align:center; gap:8px; }
          .game-stats { justify-content:center; margin-left:0; }
        }
      `}</style>
    </div>
  );
};

export default BiologyGame;
